"use strict";(self.webpackChunkdbt_osmosis=self.webpackChunkdbt_osmosis||[]).push([[266],{2206:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-yaml/inheritance","title":"Inheritance","description":"Overview","source":"@site/docs/tutorial-yaml/inheritance.md","sourceDirName":"tutorial-yaml","slug":"/tutorial-yaml/inheritance","permalink":"/dbt-osmosis/docs/tutorial-yaml/inheritance","draft":false,"unlisted":false,"editUrl":"https://github.com/z3z1ma/dbt-osmosis/tree/main/docs/docs/tutorial-yaml/inheritance.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Context Variables","permalink":"/dbt-osmosis/docs/tutorial-yaml/context"},"next":{"title":"Settings resolution","permalink":"/dbt-osmosis/docs/explanation/settings-resolution"}}');var t=i(4848),r=i(8453);const o={sidebar_position:3},l="Inheritance",a={},c=[{value:"Overview",id:"overview",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"1. Building an Ancestor Tree",id:"1-building-an-ancestor-tree",level:3},{value:"2. Aggregating a \u201cKnowledge Graph\u201d",id:"2-aggregating-a-knowledge-graph",level:3},{value:"3. Handling Renames and Fuzzy Matching",id:"3-handling-renames-and-fuzzy-matching",level:3},{value:"4. Updating the Child Node",id:"4-updating-the-child-node",level:3},{value:"Example",id:"example",level:2},{value:"When Columns Diverge",id:"when-columns-diverge",level:2},{value:"Config Flags That Control Inheritance",id:"config-flags-that-control-inheritance",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Takeaways",id:"takeaways",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"inheritance",children:"Inheritance"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["One of the most powerful features of dbt-osmosis is ",(0,t.jsx)(n.strong,{children:"multi-level column documentation inheritance"}),". This means ",(0,t.jsx)(n.strong,{children:"all"})," relevant tags, descriptions, and meta fields for your columns can ",(0,t.jsx)(n.strong,{children:"cascade"})," from ",(0,t.jsx)(n.strong,{children:"any"})," upstream node to your current model."]}),"\n",(0,t.jsx)(n.p,{children:"For instance, if:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Source"})," ",(0,t.jsx)(n.code,{children:"salesforce"})," defines a column ",(0,t.jsx)(n.code,{children:"contact_id"})," with a thorough description and some compliance tags (e.g. ",(0,t.jsx)(n.code,{children:'["GDPR", "PII"]'}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"staging model"})," aliases it to the same column name (",(0,t.jsx)(n.code,{children:"contact_id"}),") but doesn\u2019t bother re-describing it."]}),"\n",(0,t.jsxs)(n.li,{children:["A subsequent ",(0,t.jsx)(n.strong,{children:"intermediate"})," model references that staging model without modifying or renaming the column\u2026"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["dbt-osmosis can detect that the final model\u2019s ",(0,t.jsx)(n.code,{children:"contact_id"})," inherits documentation from the source. This approach ensures ",(0,t.jsx)(n.strong,{children:"DRY"})," docs: define them once, pass them everywhere."]}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.h3,{id:"1-building-an-ancestor-tree",children:"1. Building an Ancestor Tree"}),"\n",(0,t.jsxs)(n.p,{children:["When dbt-osmosis looks at a given node (model, seed, or source), it first builds an ",(0,t.jsx)(n.strong,{children:"ancestor tree"})," by traversing all upstream dependencies\u2014including ",(0,t.jsx)(n.strong,{children:"multiple"})," levels of parents. Concretely:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It ignores ephemeral nodes (which typically aren\u2019t documented or part of the lineage)."}),"\n",(0,t.jsxs)(n.li,{children:["It collects every ",(0,t.jsx)(n.strong,{children:"unique"})," ancestor node (source, seed, or model)."]}),"\n",(0,t.jsxs)(n.li,{children:["If a node has more than one ancestor, it includes them ",(0,t.jsx)(n.strong,{children:"all"})," (not just the direct parent)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Internally, this is driven by ",(0,t.jsx)(n.code,{children:"_build_node_ancestor_tree(...)"})," in the code. The result is a structure that might look like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  "generation_0": ["model.my_project.intermediate.my_node"],       # the current node\n  "generation_1": ["model.my_project.staging.salesforce_contacts"],\n  "generation_2": ["source.my_project.salesforce"]                 # the farthest removed ancestor\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-aggregating-a-knowledge-graph",children:"2. Aggregating a \u201cKnowledge Graph\u201d"}),"\n",(0,t.jsxs)(n.p,{children:["dbt-osmosis then ",(0,t.jsx)(n.strong,{children:"reverses"})," that tree so it can start from the ",(0,t.jsx)(n.strong,{children:"oldest"})," ancestor (like your source) and move ",(0,t.jsx)(n.strong,{children:"forward"})," in time through staging or intermediate nodes. It effectively layers each node\u2019s documentation onto the final child. This is handled by ",(0,t.jsx)(n.code,{children:"_build_column_knowledge_graph(...)"}),", which:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Examines ",(0,t.jsx)(n.strong,{children:"every"})," column in your final node."]}),"\n",(0,t.jsx)(n.li,{children:"Looks for matches in each ancestor\u2019s columns."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merges"})," any descriptions, tags, meta fields, or other specified keys from the ancestor into the child\u2019s doc if the child\u2019s doc is missing or is a placeholder."]}),"\n",(0,t.jsx)(n.li,{children:"Skips ephemeral nodes and merges from all others."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["As it merges, it respects your config flags, e.g. ",(0,t.jsx)(n.code,{children:"--skip-merge-meta"})," or ",(0,t.jsx)(n.code,{children:"--skip-add-tags"}),". If the child already has a ",(0,t.jsx)(n.strong,{children:"non-empty"})," description, it won\u2019t overwrite it (unless you used ",(0,t.jsx)(n.code,{children:"--force-inherit-descriptions"}),"). If the child has only a placeholder, that is replaced with the upstream doc."]}),"\n",(0,t.jsx)(n.h3,{id:"3-handling-renames-and-fuzzy-matching",children:"3. Handling Renames and Fuzzy Matching"}),"\n",(0,t.jsxs)(n.p,{children:["By default, dbt-osmosis expects ",(0,t.jsx)(n.strong,{children:"exact"})," column name matches to pass doc down. However, the code also includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FuzzyCaseMatching"}),": handles uppercase vs. lowercase variations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FuzzyPrefixMatching"}),": can strip known prefixes, e.g. if your staging model renamed ",(0,t.jsx)(n.code,{children:"contact_id"})," to ",(0,t.jsx)(n.code,{children:"stg_contact_id"})," but you still want to treat them as the same column."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In the future, these hooks may expand further for more advanced fuzzy matches or ignoring certain patterns. You can also implement your own plugin to handle custom rename rules."}),"\n",(0,t.jsx)(n.h3,{id:"4-updating-the-child-node",children:"4. Updating the Child Node"}),"\n",(0,t.jsxs)(n.p,{children:["Finally, once the \u201cknowledge graph\u201d is built, dbt-osmosis updates each column in the child node. This step is done by ",(0,t.jsx)(n.code,{children:"inherit_upstream_column_knowledge(...)"}),". If the child column is missing data\u2014like a description\u2014it\u2019s ",(0,t.jsx)(n.strong,{children:"populated"})," with the best available doc from an upstream ancestor."]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"Imagine a lineage chain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"source.salesforce \u2192 staging.salesforce_contacts \u2192 intermediate.int_contacts \u2192 marts.int_contacts_reporting\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Your ",(0,t.jsx)(n.code,{children:"source.salesforce"})," might say:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'columns:\n  - name: contact_id\n    description: "Unique ID for each contact from Salesforce"\n    tags: ["PII", "GDPR"]\n  - name: email\n    description: "Primary email address of the contact"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Your ",(0,t.jsx)(n.code,{children:"staging.salesforce_contacts"})," might not redefine ",(0,t.jsx)(n.code,{children:"contact_id"})," or ",(0,t.jsx)(n.code,{children:"email"}),". So dbt-osmosis sees they are \u201cinherited.\u201d Then your ",(0,t.jsx)(n.code,{children:"intermediate.int_contacts"})," has ",(0,t.jsx)(n.code,{children:"contact_id"}),", but changes the description to \u201cContact ID, updated daily.\u201d So, by the time we get to ",(0,t.jsx)(n.code,{children:"marts.int_contacts_reporting"}),", that new description has priority. We still preserve the original compliance tags from the source unless you removed or modified them along the way."]}),"\n",(0,t.jsx)(n.h2,{id:"when-columns-diverge",children:"When Columns Diverge"}),"\n",(0,t.jsx)(n.p,{children:"If at some point you rename columns or drastically change their meaning (while still using the same name upstream), dbt-osmosis stops short of forcing them to match. You can:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Manually"})," override the doc in the child to reflect the new meaning."]}),"\n",(0,t.jsx)(n.li,{children:"If you truly want them to be distinct, you give it a different name, thus skipping inheritance for that new column name."}),"\n",(0,t.jsx)(n.li,{children:"Or leverage fuzzy prefix logic if you\u2019re systematically prefixing them and still want doc to pass down."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"config-flags-that-control-inheritance",children:"Config Flags That Control Inheritance"}),"\n",(0,t.jsx)(n.p,{children:"Below are some relevant flags to refine how much doc merges:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--skip-merge-meta"}),": Skip inheriting ",(0,t.jsx)(n.code,{children:"meta"})," fields from parent nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--skip-add-tags"}),": Skip inheriting tags from upstream."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--force-inherit-descriptions"}),": Overwrite the child\u2019s existing (but possibly placeholder) descriptions with the parent\u2019s doc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--add-progenitor-to-meta"}),": Mark each column with a ",(0,t.jsx)(n.code,{children:"meta.osmosis_progenitor"})," field, so you can see ",(0,t.jsx)(n.em,{children:"which"})," node it was inherited from."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--add-inheritance-for-specified-keys=policy_tags"})," (and so on): Inherit additional custom fields from your upstream docs."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Eliminate Repetitive Docs"}),": Document columns once at the source (or the earliest staging) and let everything downstream reuse it."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Propagate Compliance Tags"}),": If ",(0,t.jsx)(n.code,{children:"GDPR"})," or ",(0,t.jsx)(n.code,{children:"PII"})," tags are attached to certain columns, they follow that column across your entire pipeline."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Promote Consistency"}),": No more \u201cdifferent descriptions for the same field.\u201d"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extendable"}),": You can create your own fuzzy matching logic if your naming patterns are more complex."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robust Fuzzy Matching"}),": Extending column name matching to handle more patterns or partial renames."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"External Data Dictionary"}),": Ingest a CSV or JSON dictionary of columns and doc them as if they were an upstream node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration with LLMs"}),": Combining the knowledge graph with an LLM to automatically fill out doc for columns that have none\u2014",(0,t.jsx)(n.strong,{children:"dbt-osmosis"})," already supports ",(0,t.jsx)(n.code,{children:"--synthesize"})," for OpenAI, but deeper integration is possible."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ignoring Common Prefixes"}),": For example, ignoring \u201cstg_\u201d or \u201cdim_\u201d while linking columns between child and parent."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"takeaways",children:"Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Multi-level column inheritance"})," is a central feature of dbt-osmosis that drastically cuts down on repetitive documentation. By building a knowledge graph from all upstream nodes, dbt-osmosis ensures each model or source gets the most complete doc possible for every column, while letting you override or skip certain merges as needed. Whether you want to unify compliance tags, pass down descriptions, or unify large parts of your lineage, ",(0,t.jsx)(n.strong,{children:"inheritance"})," is how you keep your doc consistent without repeating yourself."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);